# ============================================
# 示例：非确定性调度演示
# 功能：展示任务执行顺序的随机性
# ============================================
#
# 这个例子展示：
# 1. `async` 产生3个 future
# 2. Scheduler 随机选择任务执行（run_one_random）
# 3. 多次运行结果一样，但执行顺序不同
# 4. dummy 变量作为调度点（模拟其他工作）
# 5. **最后 `x + y + z` 会注册 continuation**
#    → 如果任务在调度器中还没执行完，完成时会 call continuation
#
# "任务完成"指：
#    Scheduler 执行完 `eval_cps env e`，调用 `complete id v`
#
# 用法：
#   多次运行观察日志顺序的变化：
#   ./sub_async.exe example.sub
#   ./sub_async.exe example.sub  (再来一次)
#
# 预期现象：
#   Run 1: Future #0, #1, #2 (顺序执行)
#   Run 2: Future #2, #0, #1 (乱序！)
#   Run 3: Future #1, #0 完成，#2 按需强制
#

let x = async (2 + 3) in
let y = async (10 * 10) in
let z = async (7 * 8) in
let dummy1 = 1 in
let dummy2 = 2 in
let dummy3 = 3 in  # <- Scheduling point: will execute some futures
let dummy4 = 4 in
let dummy5 = 5 in
let dummy6 = 6 in  # <- Another scheduling point
x + y + z

;;

# Try running multiple times to see different orders!
# Expected output variations:
#   - Some runs: futures executed in order #0, #1, #2
#   - Other runs: different order like #2, #1, #0
#   - Some runs: only 1-2 futures executed, rest forced on-demand

# Try running this multiple times:
#   ./sub_async example.sub
# 
# You should see different execution orders like:
#   Run 1: futures #1, #2, #0 completed (in that order)
#   Run 2: futures #2, #0, #1 completed (different order!)
#   Run 3: future #1 completed, then #0 and #2 forced on-demand
#
# This demonstrates: "算出来的顺序，是否乱的" (whether computation order is random)

