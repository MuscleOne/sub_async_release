# 08_impossible_cycle.sub - Attempting to create a cycle
#
# Question: Can we create a circular dependency in the computation graph?
#
# Answer: NO! The language design prevents it.
#
# Why cycles are impossible:
# 1. Let bindings are sequential (x must be defined before y uses it)
# 2. Static scoping (no forward references)
# 3. No mutable references (can't modify existing futures)
#
# This test demonstrates why cycles CANNOT occur:

# Attempt 1: Forward reference (will fail at parse/type-check)
# let x = y + 1 in           # ❌ Error: y not defined yet
# let y = x + 1 in
# x

# Attempt 2: Self-reference (will fail)
# let x = x + 1 in           # ❌ Error: x used in its own definition

# Attempt 3: The "closest" we can get to a cycle (not actually a cycle!)
let a = async (10) in        # Future 0
let b = a + 1 in             # Future 1: depends on [0]
let c = b + 1 in             # Future 2: depends on [1]
let d = c + a in             # Future 3: depends on [2, 0] ← NOT a cycle!
d

# Dependency graph for Attempt 3:
#
#   Future 0 (a = async 10)
#     ↓  ↘
#     ↓   Future 1 (b = a + 1)
#     ↓     ↓
#     ↓   Future 2 (c = b + 1)
#     ↓     ↓
#     ↘   ↙
#   Future 3 (d = c + a)
#
# This is a DAG (Directed Acyclic Graph), not a cycle!
# Future 3 has TWO dependencies [2, 0], but there's no back edge.
